документы хранятся в бд как таблица с обязательными \_id, а остальные поля хранятся в поле fields. доки закреплены за проектами, у проектов есть id, title и так далее.

```
doc_69 {
  id: 123,
  fields: [...],
}
```

fields документа включает в себя поля документа

```
fields: [
  {
    id: 123,
    type: ...,
  },
  {
    id: 456,
    type: ...,
  },
],
```

так можно будет

```
table project {
  id: 000
  documents: Document[]
}

найти поле, name которого == surname и документ в котором оно находится имеет id === 000

table Document {
  id: 123
  project_id: 000
  fields: (json) {
    name: surname
    type: string/number/date
    value: ?
  }[]
}
```

найти field где name === "surname" и вернуть все поле

# клиент

клиент просит конфиг, в котором указан айди проекта, делает подключение и предоставляет контекст через провайдер чтобы все хуки админки могли пользоваться этим контекстом

клиент отдает функции для изменения полей в json документа, с их помощью можно построить какой угодно компонент, но можно использовать и стандартные

path будет предоставлен каждому филдсету, чтобы тот знал куда записывать новое значение и откуда его брать, path будет массивом из строк и чисел

у всех инпутов есть onChange, поэтому нужно сделать 1 место где определяется этот метод одной формы вне зависимости от типа значения

если хранить `Field` в форме таблицы с полями `name`(`string`) и `value`(`json`), то выйдет хранить любое сериализуемое значение, даже массивы. но массивы могут быть любого типа даже нескольких одновременно, что будет указано при создании нового пункта массива. например, массив может включать строку, число и дкоумент типа `employee` одновременно. тогда его запись будет выглядеть так

если я буду хранить поле `_type` в бд, то когда значение приходит с бд я могу сравнивать его тип и тип в поле инпута админки (но наверное сравнивать просто по значению легче?, а что если объект или массив?). если не хранить тип, то можно написать кастомный проверщик, который рекурсивно определяет путь до значения которого нет для объектив и массивов

```
field {
  name: username
  type: string
}
```

клиент предоставляет студии `projectId` и она передает его в путь, затем там путь читается и устанавливается сокет соединение

для кастомизации студии использовать css переменные, тк стоит tailwind

использовать https://reactrouter.com/start/declarative/routing#splats для студии вместо танстака
